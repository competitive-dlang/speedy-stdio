/*
 * A faster replacement for some subset of std.stdio
 * Copyright © 2022, Siarhei Siamashka
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
module speedy.stdio;
@safe:

private const BUFSIZE = 32 * 1024;

private struct SpeedyWriter
{
    import std.range, std.algorithm, std.traits, core.bitop;

    private static bool isChar(T)()
    {
        return isSomeChar!T && T.sizeof == 1;
    }

    private static bool isString(T)()
    {
        return is(T == string);
    }

    private static bool isNogcCompatibleNested(T)()
    {
        static if (isIntegral!T)
            return true;
        else static if (isInputRange!T || isArray!T)
            return isNogcCompatibleNested!(ElementType!T);
        else
            return false;
    }

    private static bool isNogcCompatible(T)()
    {
        static if (isIntegral!T || isString!T || isChar!T)
            return true;
        else static if (isInputRange!T || isArray!T)
            return isNogcCompatibleNested!(ElementType!T);
        else
            return false;
    }

    shared static char[BUFSIZE] outbuf;
    shared static ptrdiff_t outbuf_size = 0;

    // Writing to the actual STDOUT can be suppressed if this variable is set
    // to 'true'
    shared static bool silenced = false;

    static bool buffer_contains(string expected_data) @nogc @trusted
    {
        return expected_data == cast(string) outbuf[0 .. outbuf_size];
    }

    version (Posix)
    {

        static void rawWriteStdout(char[] buffer) @nogc @trusted
        {
            if (silenced)
                return;
            import core.sys.posix.unistd : write, STDOUT_FILENO;
            import core.sys.posix.fcntl, core.stdc.errno;

            while (buffer.length > 0)
            {
                auto result = write(STDOUT_FILENO, cast(void*) buffer.ptr, buffer.length);
                if (result > 0)
                {
                    buffer = buffer[result .. $];
                    continue;
                }
                assert(result == -1 && (errno == EAGAIN || errno == EINTR), "unexpected error type");
            }
        }
    }

    version (Windows)
    {

        static void rawWriteStdout(char[] buffer) @nogc @trusted
        {
            if (silenced)
                return;
            import core.sys.windows.windows;

            auto h = GetStdHandle(STD_OUTPUT_HANDLE);
            while (buffer.length > 0)
            {
                uint actual_written;
                auto result = WriteFile(h, cast(void*) buffer.ptr, cast(uint) buffer.length, &actual_written, null);
                if (result && actual_written > 0)
                {
                    buffer = buffer[actual_written .. $];
                    continue;
                }
                assert(result, "unexpected error");
            }
        }
    }

    static flush() @nogc @trusted
    {
        if (outbuf_size > 0)
            rawWriteStdout(cast(char[]) outbuf[0 .. outbuf_size]);
        outbuf_size = 0;
    }

    shared static ~this()
    {
        flush();
    }

    static void put(T)(T ch) @nogc @trusted if (isChar!T)
    {
        if (outbuf_size < outbuf.sizeof)
        {
            outbuf[outbuf_size] = ch;
            outbuf_size = outbuf_size + 1;
        }
        else
        {
            rawWriteStdout(cast(char[]) outbuf[0 .. outbuf_size]);
            outbuf[0] = ch;
            outbuf_size = 1;
        }
    }

    static void ensure_outbuf_capacity(ptrdiff_t size) @nogc @trusted
    {
        if (outbuf_size + size > outbuf.sizeof)
        {
            rawWriteStdout(cast(char[]) outbuf[0 .. outbuf_size]);
            outbuf_size = 0;
            assert(size <= outbuf.sizeof, "write buffer is too small");
        }
    }

    // Compute the number of digits of an integer quickly. Public domain code from Daniel Lemire:
    //  * https://github.com/lemire/Code-used-on-Daniel-Lemire-s-blog
    //  * https://lemire.me/blog/2021/06/03/computing-the-number-of-digits-of-an-integer-even-faster/
    static int fast_digit_count(uint x) @nogc
    {
        static immutable table = [
            4294967296, 8589934582, 8589934582, 8589934582, 12884901788,
            12884901788, 12884901788, 17179868184, 17179868184, 17179868184,
            21474826480, 21474826480, 21474826480, 21474826480, 25769703776,
            25769703776, 25769703776, 30063771072, 30063771072, 30063771072,
            34349738368, 34349738368, 34349738368, 34349738368, 38554705664,
            38554705664, 38554705664, 41949672960, 41949672960, 41949672960,
            42949672960, 42949672960
        ];
        assert(x != 0);
        return (x + table[bsr(x)]) >> 32;
    }

    static int fast_digit_count(ulong x) @nogc
    {
        static immutable table = [
            4503599627370495, 9007199254740982, 9007199254740982,
            9007199254740982, 13510798882111438, 13510798882111438,
            13510798882111438, 18014398509481484, 18014398509481734,
            18014398509481734, 22517998136849980, 22517998136849980,
            22517998136851230, 22517998136851230, 27021597764210476,
            27021597764210476, 27021597764216726, 31525197391530972,
            31525197391530972, 31525197391530972, 36028797018651468,
            36028797018651468, 36028797018651468, 36028797018651468,
            40532396644771964, 40532396644771964, 40532396644771964,
            45035996258079960, 45035996265892460, 45035996265892460,
            49539595822950456, 49539595822950456, 49539595862012956,
            49539595862012956, 54043195137820952, 54043195137820952,
            54043195333133452, 58546793202691448, 58546793202691448,
            58546793202691448, 63050385017561944, 63050385017561944,
            63050385017561944, 63050385017561944, 67553945582432440,
            67553945582432440, 67553945582432440, 72057105756677936,
            72057349897302936, 72057349897302936, 76558752259048432,
            76558752259048432, 76559972962173432, 76559972962173432,
            81052586261418928, 81052586261418928, 81058689777043928,
            85507357763789424, 85507357763789424, 85507357763789424,
            89766816766159920, 89766816766159920, 89766816766159920,
            89766816766159920
        ];
        assert(x != 0);
        int floor_log2_x = bsr(x);
        return (table[floor_log2_x] + (x >> (floor_log2_x / 4))) >> 52;
    }

    // Construct digits conversion table at compile time

    static immutable digitsbatch = 4;

    static immutable tbl = {
        char[(10 ^^ digitsbatch) * digitsbatch] result;
        foreach (i; 0 .. (10 ^^ digitsbatch))
        {
            int v = i;
            foreach_reverse (j; 0 .. digitsbatch)
            {
                result[i * digitsbatch + j] = '0' + v % 10;
                v /= 10;
            }
        }
        return result;
    }();

    static void put(T)(T val) @nogc if (isIntegral!T)
    {
        if (val == 0)
        {
            put('0');
            return;
        }
        if (val < 0)
        {
            put('-');
            val = -val;
        }
        Unsigned!T v = val;

        ptrdiff_t ndigits = fast_digit_count(v);
        ensure_outbuf_capacity(ndigits);

        ptrdiff_t i = outbuf_size + ndigits - digitsbatch;
        while (i >= outbuf_size)
        {
            auto newv = v / (10 ^^ digitsbatch);
            auto rem = v - newv * (10 ^^ digitsbatch);
            v = newv;
            ptrdiff_t j = cast(ptrdiff_t) rem * digitsbatch;
            outbuf[i .. i + digitsbatch] = tbl[j .. j + digitsbatch];
            i -= digitsbatch;
        }
        if (i < outbuf_size)
        {
            size_t lastbatch = digitsbatch - (outbuf_size - i);
            ptrdiff_t j = cast(ptrdiff_t) v * digitsbatch + digitsbatch - lastbatch;
            static if (digitsbatch <= 4)
            {
                i = outbuf_size;
                if (lastbatch & 2)
                {
                    outbuf[i .. i + 2] = tbl[j .. j + 2];
                    i += 2;
                    j += 2;
                }
                if (lastbatch & 1)
                    outbuf[i] = tbl[j];
            }
            else
            {
                outbuf[outbuf_size .. outbuf_size + lastbatch] = tbl[j .. j + lastbatch];
            }
        }
        outbuf_size = outbuf_size + ndigits;
    }

    static void put(string str) @nogc @trusted
    {
        while (str.length > 0)
        {
            if (outbuf_size == outbuf.sizeof)
            {
                rawWriteStdout(cast(char[]) outbuf[0 .. outbuf_size]);
                outbuf_size = 0;
            }
            ptrdiff_t chunksize = min(str.length, outbuf.sizeof - outbuf_size);
            outbuf[outbuf_size .. outbuf_size + chunksize] = str[0 .. chunksize];
            str = str[chunksize .. $];
            outbuf_size = outbuf_size + chunksize;
        }
    }

    static void put(Range)(Range r) if ((isInputRange!Range || isArray!Range) && isNogcCompatible!(ElementType!Range))
    {
        static if (isChar!(ElementType!Range))
        {
            put_with_joiner(r, "");
        }
        else
        {
            put('[');
            put_with_joiner(r, ", ");
            put(']');
        }
    }

    static void put_with_joiner(Range, T)(Range r, T sep) @nogc
            if ((isInputRange!Range || isArray!Range) && (isString!T || isChar!T))
    {
        bool first = true;
        foreach (x; r)
        {
            if (!first)
                put(sep);
            static if (isNogcCompatible!(typeof(x)))
                put(x);
            else
                put_gc(x);
            first = false;
        }
    }

    // fallback to std.conv for the types, which are not supported
    static void put_gc(T)(T val)
    {
        import std.conv;

        put(val.to!string);
    }
}

// From: https://github.com/dlang/phobos/blob/master/std/concurrency.d
import core.atomic, core.thread;
static shared struct SpinLock
{
    void lock() @nogc @trusted { while (!cas(&locked, false, true)) { Thread.yield(); } }
    void unlock() @nogc { atomicStore!(MemoryOrder.rel)(locked, false); }
    bool locked;
}
static shared SpinLock SpeedyWriterLock;

///////////////////////////////////////////////////////////////////////////////

void write(T...)(T args)
{
    SpeedyWriterLock.lock();
    foreach (arg; args)
        static if (SpeedyWriter.isNogcCompatible!(typeof(arg)))
            SpeedyWriter.put(arg);
        else
            SpeedyWriter.put_gc(arg);
    SpeedyWriterLock.unlock();
}

void writeln(T...)(T args)
{
    SpeedyWriterLock.lock();
    foreach (arg; args)
        static if (SpeedyWriter.isNogcCompatible!(typeof(arg)))
            SpeedyWriter.put(arg);
        else
            SpeedyWriter.put_gc(arg);
    SpeedyWriter.put('\n');
    SpeedyWriterLock.unlock();
}

///////////////////////////////////////////////////////////////////////////////

import std.format;

private struct SpeedyWriterSink
{
    void put(T)(T arg) { SpeedyWriter.put(arg); }
}

void writef(alias fmt, A...)(A args)
{
    SpeedyWriterLock.lock();
    SpeedyWriterSink s;
    formattedWrite!fmt(s, args);
    SpeedyWriterLock.unlock();
}

void writef(Char, A...)(in Char[] fmt, A args)
{
    SpeedyWriterLock.lock();
    SpeedyWriterSink s;
    formattedWrite(s, fmt, args);
    SpeedyWriterLock.unlock();
}

void writefln(alias fmt, A...)(A args)
{
    SpeedyWriterLock.lock();
    SpeedyWriterSink s;
    formattedWrite!fmt(s, args);
    SpeedyWriter.put('\n');
    SpeedyWriterLock.unlock();
}

void writefln(Char, A...)(in Char[] fmt, A args)
{
    SpeedyWriterLock.lock();
    SpeedyWriterSink s;
    formattedWrite(s, fmt, args);
    SpeedyWriter.put('\n');
    SpeedyWriterLock.unlock();
}

///////////////////////////////////////////////////////////////////////////////

@nogc unittest
{
    SpeedyWriter.silenced = true;
    SpeedyWriter.flush;
    writeln(1);
    write(2);
    write("hello");
    writeln(7, "xyz");
    int[3] a = [1, -2, 3];
    write(true);
    write(a);
    int[2][2] b = [[7, 8], [9, 10]];
    write(b);
    write(1 > 2);
    auto expected_data = "1\n2hello7xyz\ntrue[1, -2, 3][[7, 8], [9, 10]]false";
    assert(SpeedyWriter.buffer_contains(expected_data));
}

@nogc unittest
{
    SpeedyWriter.silenced = true;
    SpeedyWriter.flush;
    writeln(int.min);
    writeln(int.max);
    writeln(uint.min);
    writeln(uint.max);
    writeln(long.min);
    writeln(long.max);
    writeln(ulong.min);
    writeln(ulong.max);
    auto expected_data = "-2147483648\n2147483647\n0\n4294967295\n" ~
        "-9223372036854775808\n9223372036854775807\n" ~
        "0\n18446744073709551615\n";
    assert(SpeedyWriter.buffer_contains(expected_data));
}

unittest
{
    SpeedyWriter.silenced = true;
    SpeedyWriter.flush;
    string[2] a = ["abc", "xyz"];
    writeln(a);
    auto expected_data = "[\"abc\", \"xyz\"]\n";
    assert(SpeedyWriter.buffer_contains(expected_data));
}

unittest
{
    SpeedyWriter.silenced = true;
    SpeedyWriter.flush;
    wchar c = 'ß';
    dstring s = "ÄÖÜ";
    writeln(c, s);
    auto expected_data = "ßÄÖÜ\n";
    assert(SpeedyWriter.buffer_contains(expected_data));
}

unittest
{
    SpeedyWriter.silenced = true;
    SpeedyWriter.flush;
    wchar[2] a;
    a[0] = 'ß';
    a[1] = 'Ä';
    auto b = new dchar[3];
    b[0] = 'Ä';
    b[1] = 'Ö';
    b[2] = 'Ü';
    writeln(a, b);
    auto expected_data = "ßÄÄÖÜ\n";
    assert(SpeedyWriter.buffer_contains(expected_data));
}

unittest
{
    import std.typecons : tuple;

    SpeedyWriter.silenced = true;
    SpeedyWriter.flush;
    writeln(tuple(int.min, int.max), ' ', int.min, ' ', int.max);
    auto expected_data = "Tuple!(int, int)(-2147483648, 2147483647) -2147483648 2147483647\n";
    assert(SpeedyWriter.buffer_contains(expected_data));
}

@system unittest
{
    import std.parallelism, std.range;
    SpeedyWriter.silenced = true;
    SpeedyWriter.flush;
    int n = 1000;
    foreach (i; taskPool.parallel(iota(n)))
       writeln('[', ']');
    auto expected_data = "[]\n".replicate(n);
    assert(SpeedyWriter.buffer_contains(expected_data), "multithreaded test");
}

unittest
{
    SpeedyWriter.silenced = true;
    SpeedyWriter.flush;
    writef!"%d %d"(12, 34);
    writef(" %d %d", 56, 78);
    auto expected_data = "12 34 56 78";
    assert(SpeedyWriter.buffer_contains(expected_data), "writef failed");
}
